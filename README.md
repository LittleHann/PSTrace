# PSTrace

Powershell v2 enable ScriptBlock Tracing.

Log every script and command to event log of any powershell.exe launched on target (even exe pushed by attacker ;-))

# Why

In older version of Powershell, there is no way to trace all calling scripts, as we can see on modern Powershell implementation through AMSI (Anti Malware Scan Interface), or via ETW provider (Microsoft-Windows-Powershell). 
This is a huge advantage for attacker side on platform like Windows 7 or Windows Server 2008.

To monitor this kind of attack, we explored some solution exposed by security researcher : 
* https://github.com/tandasat/DotNetHooking from Crowdstrike
* https://cansecwest.com/slides/2017/CSW2017_Amanda_Rousseau_.NETHijackingPowerShell.pdf from Endgame

This is our main sources of inspiration for doing PSTrace.

# Build

PSTrace use massively Cmake to do the job, and it is mandatory before build step:
https://github.com/Kitware/CMake/releases/download/v3.13.4/cmake-3.13.4-win64-x64.msi

We need wix to build installer part:
http://wixtoolset.org/releases/v3.11.1/stable

Now do the magic following commands:
```bash
git clone https://github.cert.corp/CERT/PSTrace --recursive
mkdir build_ptrace
cd build_ptrace
cmake -G "Visual Studio 15 2017 Win64" ..\ptrace
cmake --build . --target package --config release
```

Enjoy pstrace-1.0.1-win64.msi file.

Adapt "Visual Studio 15 2017 Win64" to your target compiler and platform.

For pre build Release, see Release page:
https://github.com/airbus-cert/PSTrace/releases

# How

PStrace want to log all scripts executed through powershell. But Powershell exposed lot of way to execute a script, and many interface to obfuscated it :
* Open powershell.exe and execute commands directly through console input
* Execute via powershell.exe command line parameter
* Execute an encoded command via -e command line parameter
* Execute a script deobfuscate via Invoke-Expression (alias iex) cmdlet
* Execute a command via Invoke-Command cmdlet

PSTrace must trace all this kind of execution.

Powershell.exe is just an exe which launch CLR and load main Powershell assembly :
* System.Management.Automation

We choose to follow solution exposed by Croundstrike and Endgame, and inject a .net assembly to hook some method from powershell.exe, more precisely System.Management.Automation.
But after trying both solutions, all execution mode was not covered. We have to determine a better way to hook. 

After a hard work of reversing ;-) (via ILSpy), we determinated two targeted methods :
* Instance method *InvokeWithPipe* from System.Management.Automation.ScriptBlock class
* Instance method *Invoke* from System.Management.Automation.Runspaces.Pipeline

First method, cover tracing of any invoked script which need compile step before, like Invoke-Expression or Invoke-Command, or encoded command line.
Second method cover tracing of input from console directly.

We will achieve this goal in two steps :
* Inject an assembly in target process
* Hook method before start of app

## Inject assembly

First of all, we need to inject our assembly before execution of powershell. To do that, we will create a custom domain manager which is in charge to resolve assembly on loading. To force CLR (Common Language Runtime) to use our custom domain manager, there is two environments variables to set before executing powershell :

```
set APPDOMAIN_MANAGER_ASM=PSTrace, Version=0.0.0.0, Culture=neutral, PublicKeyToken=cba672b68346b966, processorArchitecture=MSIL
set APPDOMAIN_MANAGER_TYPE=PSTrace.PSTrace
```

Note assembly must be sign to be a valid candidate for domain manager.

## Hook method

Once we are loaded into targeted application as an application domain manager, we can control assembly loading step. When an assembly is loaded, an event is emited. We just have to wait the target assembly, and find target method using reflection.
Then we just use x86/X64 inline hooking, because in fabulous world of .net we can also control the JIT compiler through RuntimeHelpers class. RuntimeHelpers.PrepareMethod just compile it, and GetFunctionPointer return a valid virtual address, which can be manipulated in asm directly.

Once method are hooked, we implement a handler that will log into event log, using Powershell as source, because is already present.

## Install

To monitor all powershell.exe process, we use Global Assembly Cache (GAC) and system Environment Variable. This is done into msi file generated by cmake.
